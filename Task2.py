# C. Домашнее задание
# Ограничение времени	2 секунды
# Ограничение памяти	512Mb
# Ввод	стандартный ввод или input.txt
# Вывод	стандартный вывод или output.txt
# Борис прошел в школе сразу две новых темы - наибольший общий делитель (НОД) и простые числа.
# Определение: наибольшим общим делителем двух целых положительных чисел A и B называют такое число G, что:
# 1.	A делится на G нацело (G является делителем A);
# 2.	B делится на G нацело (G является делителем B);
# 3.	не существует числа H такого, что G<H и H удовлетворяет условиям 1 и 2.
# Определение: число P называется простым, если у него есть ровно два различных делителя: 1 и само число P.
# К примеру:
# •	число 1 не является простым, так как у него только один делитель  — 1;
# •	4 не простое, так как у 4 есть три делителя  — 1, 2, 4;
# •	6 не простое, так как у 6 четыре различных делителя  — 1, 2, 3, 6.
# В качестве домашнего задания Борису необходимо решить T заданий следующего вида:
# «Даны два целых числа A и B, можно ровно один раз умножить либо A, либо B на любое простое число. Какого наибольшего значения НОД можно добиться с помощью такого умножения?»
# Пример:
# •	Пусть A=20, B=45. НОД(20,45)=5.
# •	При умножении числа A на простое число 3 итоговый НОД(20⋅3,45)=15.
# •	При умножении числа B на простое число 2 итоговый НОД(20,45⋅2)=10.
# Пожалуйста, ознакомьтесь с примерами тестов и пояснениями к ним для лучшего понимания условия.
# Формат ввода
# В первой строке дано целое число T (1≤T≤20)  — количество заданий.
# В каждой из следующих T строк содержатся два целых числа A и B (1≤A,B≤1012)  — параметры задания.
# Формат вывода
# Для каждого задания выведите единственное целое число  — наибольшее значение НОД, которого можно добиться умножением одного из чисел A и B на любое простое число.


i = int(input())
list_task = []
for j in range(i):
    l = input().split()
    l = list(map(int,l))
    list_task.append(l)

def simple_number_gen(n):
    simple_number = []
    for i in range(n + 1):
        simple_number.append(i)
    simple_number[1] = 0
    i = 2
    while i <= n:
        if simple_number[i] != 0:
            j = i + i
            while j <= n:
                simple_number[j] = 0
                j = j + i
        i += 1
    simple_number = set(simple_number)
    simple_number.remove(0)
    return simple_number

def nod(a, b):
    while a != 0 and b != 0:
        if a > b:
            a = a % b
        else:
            b = b % a
    return a + b

simple_number = simple_number_gen(6000000)

def one_nod(first, sec):
    max_nod = 0
    for i in simple_number:
        num = first * i
        if nod(num, sec) > max_nod:
            max_nod = nod(num, sec)
    return max_nod

def max_nod(a,b):
    return max(one_nod(a,b),one_nod(b,a))

for i in list_task:
    print(max_nod(i[0],i[1]))
